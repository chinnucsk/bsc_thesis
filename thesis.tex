\documentclass[12pt, a4paper, oneside]{book}
\usepackage[left=3.5cm, top=2.5cm, right=2.5cm, bottom=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,hungarian]{babel}
\selectlanguage{hungarian}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{listings}
\usepackage{makeidx}
\usepackage{natbib}
\usepackage{url}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\makeindex

\newenvironment{abstract}
{\newpage \pagestyle{empty} \vspace*{\fill} \begin{center}\em{Kivonat}\end{center}}
{\vspace*{\fill} \newpage}

\definecolor{light-gray}{gray}{0.6}
\lstnewenvironment{code}[2]
{\lstset{basicstyle=\footnotesize, showstringspaces=false, emphstyle=\textbf,
caption= #2,language= #1, frame=single, xleftmargin=1.5cm, xrightmargin=1.5cm,
rulecolor=\color{light-gray}, belowskip=0.75cm, aboveskip=0.5cm,
framexleftmargin=0.5cm}}
{}

\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{%
\markboth{\thechapter.%
\ \chaptername.\ #1}{}}

\fancyhead[L]{}


%\renewcommand\lstlistingname{ábra}
%\renewcommand\lstlistlistingname{Ábrák}
\lstset{caption=\thelstlisting. \lstlistingname}


\author{Czinkos Zsolt}
\title{Erlang/OTP: magas rendelkezésre állású elosztott rendszerek fejlesztése}
\date{2012-04-28}

\begin{document}
\maketitle

\onehalfspacing

\begin{abstract}
Az Erlang programozási nyelvet az Ericssonnál hozták létre hálózati
eszközök, telefonrendszerek programozására. A magas telekom elvárások
tükröződnek az Erlangban fejlesztett rendszerek architektúrájában,
amely az Open Telecom Platform szoftverkönyvtárban ölt testet. A dolgozat
bemutatja az Erlang programozási nyelvet, a fejlesztési elveket és
alkalmazási lehetőségeit a webes technológiára épülő alkalmazások területén.
\end{abstract}

\newpage
\pagestyle{empty}
\vspace*{\fill} 
\hfill \emph{Mindenkinek, aki szereti}
\vspace*{\fill} 
\newpage

\pagestyle{fancy}

\tableofcontents

\chapter{Bevezetés}

Az Internet -- azon belül különösen a Web -- terjedésével párhuzamosan nőtt az
igény kiszámítható, jó minőségű szolgáltatásokra. A szolgáltatóknak egyre
magasabb elvárásoknak kell megfelelnie -- nem utolsó sorban azért, mert a
felhasználók fejében a web és az ingyenes tartalom összeforrt. Még színvonalas
termékekért is nehezen adnak ki pénzt, nemhogy hibás, elavult tartalomért,
akadozó és kiszámíthatatlanul működő szolgáltatásokért. Ma már a hálózat nem
csupán mérnököknek, kutatóknak érdekes kábelezést jelent, amely így-úgy hasznos
a tudományos kutatásaik során, hanem a mindennapi élet részét képező társadalmi
kapcsolatok \textit{reprezentációját} is. A felhasználó egyre aktívabb
\textit{cselekvője} ezeknek a valós vagy virtuális világban létrejött
hálózatoknak, egyre inkább itt keresi (és többnyire találja meg) azt a teret,
ahol ismerik, és ő is ismer, ahol ura annak az eszköztárnak, amelynek
birtokában különböző -- rövid, prompt, aszinkron, szöveg, hang vagy videó --
\textit{üzenetek} segítségével ápolni tudja kapcsolatait. Ez a
kapcsolatrendszer és eszköztár jelenti azt az új mikroikozmoszt, amelyben a
felhasználó -- cselekvő- és befolyásolóképessége tudatában -- kényelemben és
biztonságban érzi magát.

Ez a kényelem és biztonság \textit{függővé} tesz: világunk megszokott
működésének zavarait nehezen vagy egyáltalán nem tudjuk tolerálni,
kiszolgáltatottnak és tehetetlennek érezzük magunkat. Ilyenkor derül ki, hogy
bár mikrokozmoszunkat ismerni véljük, az azt működtető rendszer elemeit meg sem
tudjuk nevezni, csak azt tudjuk, hogy \glqq{}van\textquotedblright{} (ez a
valami pillanatnyilag a legtöbb ember számára néhány cég szolgáltatásában ölt
testet: Facebook, Google, Twitter). A szoftverfejlesztőknek, tervezőknek ennek
a világnak a működtetéséhez szükséges rendszert kell tudniuk megépíteni és
üzemeltetni úgy, hogy a felhasználók a lehető legkevesebb alkalommal
szembesüljenek azzal, hogy kihúzták alóluk a talajt. Nem emberbaráti, hanem
üzleti megfontolások miatt.

A weben a sikerhez elengedhetetlen a folyamatos és megbízható szolgáltatás,
nagyon alacsony az ingerküszöb, ha egy oldal betöltődése tovább tart mint 4
másodperc, már odébb is állt a felhasználó \citep{AkamaiReport}.  Ha túl
sokszor kap hibaüzenetet -- amitől jobb esetben ingerült lesz, rosszabb esetben
halálra rémül, hátha ő rontott el valamit --, keres mást. Éppen ezért nagyon
fontos, hogy olyan rendszert építsünk, amely 

\begin{enumerate} 
  \item folyamatosan, megszakítás nélkül működik;
  \item megfelelő válaszidővel, sebességgel működik;
  \item funkcionálisan jól működik;
  \item a felmerülő hibák nyomon követhetők, kezelhetők.
\end{enumerate}

A fentebb már említett vezető webes cégek mind megfelelnek ezeknek a
követelményeknek, persze nem kevés munka és pénz árán. A felhasználót azonban a
legkevésbé sem érdekli, hogy a szolgáltatást nyújtó üzleti vállalkozás hogyan
tudja működtetni rendszerét, hány embert alkalmaz, stb. Őt az érdekli, hogy
neki ingyen vagy elérhető áron a lehető legtöbbet nyújtsa. Ez az elvárása
sajnos (vagy szerencsére) nem csak a mammutcégekkel szemben áll fent, hanem
minden webes céggel szemben, mindenhol szeretné megkapni azt a minőséget,
amihez hozzászokott. Azt a céget tekinti profinak, jónak, amely ugyanazt tudja
nyújtani. Ha egy cég sikert akar, akkor már induláskor fel kell készülnie arra,
hogy ha elsül a kapanyél, és özönlenek a felhasználók, akkor tartani tudja az
iramot, ki tudja szolgálni ugrásszerűen megnőtt ügyfélkörét; miközben egy kezdő
vállalkozás nem engedhet meg magának földrajzilag diverzifikált többtízezer
gépes szerverparkot: kicsiből indulva kell képesnek lennie a növekedésre.

Hogyan lehet olyan rendszert építeni, amellyel neki lehet vágni egy webes
vállalkozásnak úgy, hogy ne kelljen attól félni, mi lesz, ha holnap regisztrál
még 10 ezer felhasználó (4 másodperc!), vagy ha tönkremegy az egyik gép?

Számos programozási nyelv és környezet közül lehet ma már választani, amely
alkalmas erre a feladatra, ez a dolgozat az Erlang programozási nyelvet és a
hozzá kapcsolódó Open Telecom Platform-ot (OTP) mutatja be. Az Erlang egy
funkcionális programozási nyelv, amelyet az Ericsson fejlesztett ki mintegy 20
évvel ezelőtt telefonrendszerek, szoftveres kapcsolóközpontok programozásához,
a telekommunikációs iparban szokásos rendkívül magas elvárásoknak megfelelően. 

Az Erlang megalkotásánál az elsődleges cél magas rendelkezésre állású
(\emph{highly available}), hibatűrő (\emph{fault tolerant}) redundáns
rendszerek építése volt. Ez az, amire az Erlang igazán alkalmas, ez az a
terület, ahol az Erlangnak évtizedes múltja van: akár 99,999\%-os
rendelkezésre állás biztosításában. Az hozzávetőleg 5 perc kiesés
évente \citep{WikipediaNines}.

1998-ban open source-szá vált a nyelv és a platformot adó
szoftverkönyvtárak, azóta bárki használhatja bármilyen feladatra, számos
önkéntes és cég teszi be a közösbe a maga alkalmazását: HTTP szervert, NoSQL
adatbáziskezelőt, stb.

\newpage

\chapter{Elméleti alapok} 

Az Erlang nyelvet rendkívül magas rendelkezésre állású, elosztott rendszerek
készítéséhez hozták létre. Nem akadémiai környezetben született, a legfőbb cél
az volt, hogy profitot termeljenek a segítségével: a szoftverek hamarabb
készüljenek el; a megrendelő azt kapja, amit szeretett volna; a termékek
karbantarthatóak legyenek; redundáns, elosztott környezetben működjenek
(folyamatosan); kapacitásuk növelhető legyen. A vezérelv az volt, hogy ,,minden
szoftver hibás'', mindig előfordul olyan hiba, amelyet nem kellő
körültekintéssel, nem megfelelő specifikáció birtokában megírt szoftver okoz.
Nem lehet úgy tenni, mintha egy szoftver valaha is ,,készen'' lenne, és utána már
nem kellene javítani, új igényeknek megfelelően bővíteni (újabb hibákat
elkövetni). Azt is figyelembe kellett venni, hogy a magas
rendelkezésre állás megkövetelte redundáns architektúra párhuzamos programozást
igényel, nem egy processzoron kell futni, hanem többön, sőt több gépen. Az
Erlang egyik megalkotója, Joe Armstrong, az itt leírt elvekre, módszerekre a
\emph{concurrency-oriented programming} kifejezést használta.

Az Erlang lényegében egy magas szintű nyelv konkurens rendszerek
fejlesztéséhez. A párhuzamos programozás komplex feladatok esetében sokkal
képzettebb, tapasztaltabb (így drágább) fejlesztőket kíván meg, egyáltalán nem
kicsi a lépés a nem párhuzamos pogramozástól (\emph{sequential programming}).
Egyszerűen fogalmazva: egynél több cselekvő dolgozik egyazon rendszeren belül,
ezért az egyes állapotváltoztatásoknál gondoskodni kell arról, hogy a több
helyről kezdeményezett műveletek után a rendszer allapota konzisztens maradjon.

A Java nyelvben például a párhuzamos programozást a \emph{thread}-ek teszik
lehetővé, a konzisztens állapot megőrzését pedig a \emph{synchronized}
kulcsszóval jelölt metódusokkal, programblokkokkal lehet elérni. Az Erlanggal
más utat választottak, két alapra építettek: a \emph{funkcionális
programozásra} és az \emph{aktor modellre}.
 
\section{Funkcionális programozás} 

Az Erlang funkcionális programozási nyelv. Az imperatív nyelvekkel szemben,
ahol egy implicit állapot (\emph{state}) változik adott nyelvi konstrukciók
eredményeképp, a tisztán funkcionális nyelvekben nincs implicit állapot, a
függvények mellékhatás-mentesek (\emph{side effect free}). Minden függvényhívás
tartalmaz minden szükséges argumentumot, ami az eredményhez szükséges (akár
explicit állapotot is, ha szükséges), és az azonos paraméterekkel rendelkező
függvényhívások mindig ugyanazt az eredményt adják (\emph{referential
transparency}). Egyszerű matematikai példával élve: az \texttt{f(x) = x + 1}
függvény azonos x értékekre mindig azonos eredményt ad.

A széles körben elterjedt imperatív nyelvekben (Java, C) az állapot
változtatására szolgáló, a vezérlést végző nyelvi elemek egymásutáni
használatával lehet leírni a működés ,,hogyanját''. Változók értékadása,
feltételes elágazások, ciklusok adják a működés logikáját, mit mi után milyen
feltételek teljesülése esetén kell végrehajtani. Például a Fibonacci-sor Java
megvalósítása:

\begin{code}{java}{Fibonacci -- Java}
int a=0, b=1;
public static int fib(int n) {
  for(int i=0; i<n; i++) {
    int c = a;
    a = b;
    b = c + b;
  }
  return a;
}
\end{code}

A fenti egyszerű példában szerepel értékadás, feltétel vizsgálat és ciklus is.
A végrehajtás során az 'a' változó többször kap új értéket, a ciklus futásának
végén tartalmazza az eredményt.

Az Erlang deklaratív nyelv, a ,,hogyan'' helyett a ,,mit'' írja le: a fejlesztő
kifejezéseket ad meg, mintaillesztésekkel -- kijelentéseket tesz. Funkcionális
nyelveknél a függvény alapvető nyelvi elem, amelynek segítségével a működés
leírható. A Fibonacci példa Erlang változata:

\begin{code}{erlang}{Fibonacci -- Erlang}
fib(0) -> 0; 
fib(1) -> 1; 
fib(N) when N > 0 -> fib(N-1) + fib(N-2).  
\end{code} 

Ebben az esetben a fib függvény deklarációja három állítás
(\emph{function clause}), melyik argumentum esetén mit kell tenni. Az imperatív
nyelvekben megszokott struktúrák helyett más megoldásokkal kell élni. Ciklus
helyett rekurzív függvényhívásokkal, feltételes elágazás helyett a függvény
deklarációba írt kifejezéssel (jelen esetben pozitív számokra értelmezett a
függvény).

A funkcionális pogramnyelvek fontos ismérve az is, hogy a fügvények teljes jogú
elemei a nyelvnek (\emph{first class functions}). Bárhol, ahol valamilyen érték
szerepelhet, függvény is: listák, rekordok, adatszerkezetek elemeként. Függvény
argumentuma illetve visszatérési értéke is lehet függvény (\emph{higher order
functions}). Például egy lista elemeit többféle szempont szeretnénk szűrni.
Először a páros számokat, majd utána a páratlanokat:

\begin{code}{erlang}{}
Paros = fun(N) when N rem 2 == 0 -> true;
           (_)                   -> false.

Paratlan = fun(N) when N rem 2 == 1 -> true;
              (_)                   -> false.


Lista = [1, 2, 3, 4, 5, 6, 7, 8, 9].
ParosSzamok = lists:filter(Paros, Lista).
ParatlanSzamok = lists:filter(Paratlan, Lista).
\end{code}

A \texttt{lists:filter} függvény a megadott lista minden elemére lefuttatja a
\texttt{Paros} vagy a \texttt{Paratlan} függvényt, és ha igaz értéket kap
vissza, akkor bennehagyja a listában a vizsgált elemet. A \texttt{Paros}
illetve \texttt{Paratlan} függvények változók (amik nem igazi változók, csak
egyszer kaphatnak értéket), amelyek értéke egy-egy névtelen függvény
(\emph{$\lambda$ function}).

Az Erlang nem tisztán funkcionális környezet -- lévén ipari alkalmazásra
készült -- lehet írni olyan függvényeket, amelyek nem mellékhatás mentesek,
például fájl- és adatbázis műveletek. A funkcionális programozás alapelvei
azonban jelen vannak, lehet tisztán funkcionális alkalmazást is írni, és a
fentebb ismertetett elvek maradéktalanul alkalmazhatók. Nem léteznek globális
változók, amelyek értékét több függvényből is módosítani lehetne, minden
változó (pontosabban értékadás egy névhez) csak az adott függvényen belül
értelmezett, a szükséges állapotot a függvény argumentumai közt explicit kell
megadni, és a visszatérési értékbe is betenni. A párhuzamos programozást ez
nagyban megkönnyíti: nem kell attól félni, hogy egy értéket egy másik folyamat
vagy függvényhívás felülír, mindig minden ,,kézben van''. Hogyan lehet így
bármi használhatót írni? Hogyan lehet egy komplex rendszert felépíteni,
amelynek egyes moduljai inputokar várnak más moduloktól?

Az egyes folyamatok (\emph{process}) üzeneteket küldenek egymásnak, amelyek
egy-egy másolatát (nem csak egy referenciát!) kapja meg a címzett fél, az
üzenetváltás után a küldő és a fogadó fél is birtokában van az adatnak, nincs
megosztott állapot (\emph{shared state}), még véletlenül sem fordulhat elő,
hogy egyik folyamat módosít valamit, amire egy másik folyamat is épít (kivéve,
ha \emph{side-effect}-eket használ a program -- például adatbázist).

Az Erlang architektúra alapja a fentebb leírt üzenet alapú modell: az aktor
modell.

\section{Aktor modell} 

Az aktor modell létrehozását több száz, több ezer mikroprocesszorból álló
rendszerek készítése motiválta. 1973-ban írta le először Carl Hewitt. Az aktor
modell alapeleme az \emph{aktor}, azaz a cselekvő, amely önálló entitás, saját
memóriával, viselkedési mintával (\emph{behaviour}), üzenetküldési és fogadási
képességgel. Az egyes aktorok közötti kommunikációs csatorna biztosítja az
összeköttetést. Akárcsak a valós világban: a cselekvők cselekszenek valamilyen
viselkedési minta szerint, egymással üzenetet váltanak, észlelik a másik
cselekvő halálát, diszfunkcionalitását. A világ konkurens, az aktorok egymással
egy időben működnek, kommunikálnak, megfelelő protokoll szerint megértik
egymás üzeneteit, esetleg -- megállapodás alapján -- figyelnek egymásra. Ha
egyikkel történik valami, a másik észreveszi, és ha tud, csinál valami
hasznosat.

Például egy telefonbeszélgetés során két aktor üzeneteket vált egymással
(hangcsatornán keresztül):

\begin{quote}
-- Jó napot! Béla vagyok.\\
-- Jó napot! Mondja a számot.\\
-- 42.\\
-- Köszönöm.
\end{quote}
\par\noindent Vagy:
\begin{quote}
-- Jó napot! Az adóhivataltól vagyok.\\
-- Sajnálom, ez biztos téves.
\end{quote}
\noindent A fenti kis párbeszédekben a résztvevők értelmezni tudják a bejövő
üzenetet, és annak megfelelően adnak választ. Ugyanígy a számítógépes 
aktorok (Erlangban: \emph{process}) is képesek:
\begin{itemize}
  \item üzeneteket küldeni;
  \item üzeneteket fogadni;
  \item a beérkező üzeneteket minta alapján szűrni, és azokra adekvát választ
adni;
  \item meghatározni azt a viselkedés mintát, amellyel a beérkező üzeneteket
kezelni fogja;
  \item további aktorokat létrehozni;
  \item észlelni a megfigyelt aktorok leállását. 
\end{itemize}

A kommunikáció nagyon fontos eleme az aktor modellnek, az üzenetküldés
elkülöníti a kommunikáció megoldását az aktortól, lehetővé téve az aszinkron
üzenetküldést (\emph{asynchron message passing}). Az Erlang architektúra ezen a
modellen alapszik, nagyon gyorsan és hatékonyan lehet \emph{process}-eket
nagyon nagy számban indítani és futtatni; minden \emph{process} saját
memóriával, levelesládával (\emph{mailbox}) rendelkezik, egymással aszinkron
módon tudnak kommunikálni. A processzek azonosítóval rendelkeznek, ez a cím,
ahova küldeni lehet az üzenetet, és -- ami nagyon fontos a redundáns rendszerek
építésénél -- az üzenetküldés két külön gépen lévő process között teljesen
transzparens, a programozónak nem kell külön erőfeszítést tennie, ha másik
gépen lévő process-szel akar kommunikálni. A szintaxis ugyanaz helyben mint gépek
között.

A párhuzamos programozás lehetőségét ez az aktor modell nyújtja az Erlang
platformon. Nincs közös állapot (\emph{shared state}), az egyes folyamatok
aszinkron üzenetküldéssel kommunikálnak egymással, az üzenetek másolata kerül a
címzett birtokába, a feladó ,,eredeti példánya'' megmarad. A valós életben sem
törlődik az agyunkból semmi, csak mert elmondjuk másnak (kivéve esetleg az
egyetemi vizsgákat). Ez a másolás teszi lehetővé a gépek közti transzparens
kommunikációt.

\section{Elosztott (\emph{distributed}) Erlang}
Egy gép nem gép, ha magas rendelkezésre állást kell biztosítani. Hiába van
remekül megírva a szoftver, ha a hardver meghibásodik alatta vagy kimegy az
áram. Egy gép nem gép akkor sem, ha a feladat olyan időigényes, vagy olyan nagy
adatigénye van, hogy egyetlen mai számítógép sem elegendő hozzá önmagában. A
feladatot ilyenkor partícionálni kell, és az egyes részfeladatokat egymással
párhuzamosan kell elvégezni. Több gépre kell szoftvert írni, és ez az Erlang
erőssége. A fentebb röviden ismertetett funkcionális programozás elve, és az
aktor modell egyszerűbbé, átláthatóbbá teszi a programok szerkezetét, magas
szintű nyelven lehet elosztott rendszert fejleszteni, az egyes Erlang egységek
(\emph{node}) közti kommunikáció mikéntjéről mit sem kell tudni (az OSI
hálózati hierarchia applikációs szintjén biztosított protokoll, és a nyelvbe
épített egyszerű üzenetküldési, fogadási szintaxis biztosítja a teljes
transzparenciát a programozó számára).

Az Erlang hálózat alapegysége a \emph{node}. A node egy teljesen önálló Erlang
rendszer, saját névvel, virtuális géppel (\emph{virtual machine, VM}), külön
operációs rendszer folyamatban. Egy gépen egy vagy több node is futtatható,
egymáshoz való viszonyuk nem különbözik attól, mintha külön gépen futnának.
Ahhoz, hogy a node-ok egy Erlang hálózatot alkossanak, egy közös
\emph{cookie}-val kell rendelkezniük, az Erlang VM-et ezt az értéket megadva
kell elindítani. Az Erlang hálózatban minden node tud minden node-ról,
közvetlen kapcsolatban vannak egymással. Ez a hálózati felépítés korlátozza a
node-ok számát egy hálózaton belül, bizonyos szám felett már túl nagy terhelést
jelent a node-ok egymás közti adminisztrációs kommunikációja. Szerencsére node-ot lehet
rejtett üzemmódban is indítani, így nem jelenik meg a többi node listáján.

Erlang hálózatok belső, biztonságos környezetben használatosak, a klaszteren
(\emph{cluster}) kívüli világgal, az interneten keresztül, valamelyik IP alapú
protokollal -- TCP, UDP, SCTP -- lehet kommunikálni. Egy webszolgáltatás
esetében például a belső hálózat Erlang node-okból áll, a külvilág -- a
böngésző -- pedig HTTP protokollon keresztül éri el a HTTP szervert futtató
gépet. 

Elosztott rendszereknél bizonyos méret fölött, különösen földrajzilag is
diverzifikált rendszereknél a CAP-elméletnek megfelelően a következő háromból
valamelyiket fel kell adni:
\begin{description}
\item[\emph{Consistency}] \hfill \\
 A rendszer által tárolt adatok mindig, minden pillanatban konzisztensek, a
referenciák érvényesek és minden felhasználó ugyanazt látja. Ha egy darab könyv
van raktáron, és azt valaki megveszi, akkor egy másik vásárló ugyanezt a
könyvet már nem tudja megvenni, azt fogja látni, hogy elfogyott.

\item[\emph{Availability}] \hfill \\
  A kliens mindig kap választ, a rendszer mindig elérhető. A válasz lehet
sikeres vagy sikertelen végrehajtás eredménye is, a lényeg, hogy a kérést
intéző fél mindig kap információt az eredményről.

\item[\emph{Partition Tolerance}] \hfill \\
 Csak a teljes rendszer hibás működése esetén fordulhat elő, hogy a kliens
rossz választ kapjon, vagy egyáltalán ne kapjon választ.
\end{description}

\noindent A fenti korlátozás a rendszer növekedésével párhuzamosan válik
szembetűnővé. Amíg egy gép van (sok-sok redundáns diszkkel), addig minden
konzisztens, viszont a legegyszerűbb hardver hiba is elég, hogy ne legyen
elérhető. Nő a forgalom, a működtető nem akar kiesést, egyre több gépet állít
csatasorba, az adatok nem férnek már el semmilyen számítógépen, elosztott
architektúrára van szükség. Ha az is meg van, akkor felmerül, hogy ha tűz üt ki
az épületben, akkor nem lesz elérhető semmi. Földrajzilag is el kell különíteni
az egyes részeket: ekkor az a probléma, hogy meg kell oldani a konzisztens
adatmódosítást úgy, hogy közben az elérhetőség (elfogadható válaszidő) ne
sérüljön. A CAP-elmélet ezt állítja, valamelyik feltétel a háromból
mindenképpen sérül.

Az ebben a dolgozatban a .. fejezetben bemutatott alkalmazás esetében az
elérhetőségről (\emph{availability}) mondunk le. A rendszer egy Erlang
node-okból álló klasztert alkot egy biztonságos helyi hálózaton belül,
földrajzilag nincs elkülönítve egyetlen része sem (ez az irány -- nevezetesen a
konzisztencia feladása -- egy későbbi dolgozat tárgya lehet). A rendszer
állapota mindig konzisztens, és a rendszer mindaddig válaszképes, amíg akár
egyetlen node is üzemel.

A dolgozat célja nem egy Google vagy Amazon-méretű cég technológiai hátterének
elemzése, hanem az Erlang/OTP platform bemutatása, ezért ezt a feltételt dobjuk
el. Egy így felépíthető rendszer kapacitása, képességei is messze meghaladják
egy átlagos magyar vállalkozás vagy akár egyetemi tanulmányi rendszer
követelményeit. Biztosítani képes a folyamatos működést, és az elfogadható
válaszidőt (\emph{soft-realtime}).

\newpage
\noindent Üzenet küldése a \texttt{P} process-nek (ahol P értéke a process azonosítója):

\begin{code}{erlang}{}
P ! "Hello"
\end{code}

\noindent Üzenet küldése egy másik gépen futó process-nek:

\begin{code}{erlang}{}
P ! "Hello"
\end{code}

\noindent Semmi különbség. A programban nem kell külön figyelni arra, 
hogy hol van a címzett, sem arra, hogy honnan jött az üzenet. Az alábbi
kódrészlet mindkét esetben fogadja az üzenetet:

\begin{code}{erlang}{}
receive
  Message ->
      ...
end
\end{code}

A \texttt{receive} utasítás addig vár, amíg üzenet nem érkezik, majd a Message
névhez rendeli a tartalmát. Jelen esetben a \texttt{Hello} szöveget. Az utasítás
több mintát is tartalmazhat. A fenti példában bármilyen üzenet is érkezik, azt
a Message-hez rendeli.
Protokoll kialakítása.

\section{Az Erlang programozási nyelv} 
\section{Open Telecom Platform} 
Behaviours. Supervisor hierarchies.  

\chapter{Soft realtime messaging -- a simple demo}

\chapter{A messaging szerver}
\section{Felépítés}
\section{Hibatűrés}
\section{Elosztott rendszer -- kell a redundancia}

\chapter{Web interfész}
\section{RESTful webservices}
\section{HTML5 -- websockets}

\chapter{Üzemeltetés, karbantartás}
\section{Naplózás}
Event manager, event handler.
\section{Hibakeresés}
Trace.
\section{Hibajavítás, verzióléptetés}
Upgrade.
\section{Szállítás}

\chapter{Alkalmazási lehetőségek, kitekintés}

\chapter{Összegzés}
\appendix

{\footnotesize

\begin{lstlisting}[emph={fun}, emphstyle=\textbf, caption=Map reduce module, language=erlang, frame=single]
-module(mapreduce).

start() ->
  spawn(fun() -> init() end).

init() ->
  loop().

loop() ->
  receive
    {From, To, What} ->
      io:format("~p sent to ~p a message ~p~n", [From,To,What]),
      loop();
    _ -> % avoid full msg box
      io:format("Nothing. Finish.")
  end.

\end{lstlisting}
}

\begin{thebibliography}{9}

\harvarditem[Armstrong]{}{2003}{ArmstrongThesis}
Armstrong, Joe (2003): \emph{Making reliable distributed systems in the presence of software errors}. PhD.
thesis, The Royal Institute of Technology Stockholm, Sweden. Web:
\url{http://www.erlang.org/download/armstrong_thesis_2003.pdf}, letöltés dátuma: 2012-04-01

\harvarditem[Armstrong]{}{2007}{ArmstrongBook}
Armstrong, Joe (2007): \emph{Programming Erlang: Software for a Concurrent World}. USA: The Pragmatic
Bookshelf.

\harvarditem[Cesarini]{}{2009}{CesariniBook}
Cesarini, Francesco – Thomson, Simon (2009): \emph{Erlang programming}. USA: O'Reilly Media.

\harvarditem[Logan et al.]{}{2011}{OTPInAction}
Logan, Martin – Merritt, Eric – Carlsson, Richard (2011): \emph{Erlang and OTP in Action}. USA:
Manning Publications.

\harvarditem[Fielding]{}{2001}{Fielding}
Fielding, Roy Thomas (2001): \emph{Architectural Styles and the Design of Network-based Software
Architectures}. PhD. thesis, University of California, Irvine. Web:
\url{http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf}, letöltés dátuma: 2012-04-
01.

\harvarditem[Erlang documentáció]{}{2012}{ErlangDoc}
Erlang documentation... (2011) Web: \url{http://www.erlang.org}

\harvarditem[Akamai felmérés]{}{2006}{AkamaiReport} 
Akamai felmérés (2006): \emph{Retail web site performance: Consumer Reaction to a Poor Online
Shopping Experience}
\url{http://www.akamai.com/dl/reports/Site_Abandonment_Final_Report.pdf}

\end{thebibliography}

\clearpage
\addcontentsline{toc}{chapter}{Tárgymutató}
\printindex

\end{document}
